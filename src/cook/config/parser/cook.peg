// This file contains the PEG grammar definition that Mouse uses to generate our parser.
// http://en.wikipedia.org/wiki/Parsing_expression_grammar
//
// CookConfig grammar

CookConfig         = Spacing Statement* EOT                                    {cookConfig} ;

Statement          = ( FuncStatement / FuncDef )                               {statement} ;

FuncCall           = !Keyword Identifier LPAR ArgList? RPAR                    {funcCall} ;

ListComprehensions = LBRK Expr FOR Identifier IN Identifier ( IF Expr )? RBRK  {listComprehensions} ;

Assginment         = !Keyword Identifier EQU Expr                              {assginment} ;

Expr               = ExprItem ( Operation ExprItem )*                          {expr} ;

ExprItem           = ( ExprItemWithSuffix
                     / ExprItemWithUnary
                     )                                                         {exprItem} ;


ExprItemWithSuffix = SimpleExprItem ( SelectorSuffix )*                        {exprItemWithSuffix} ;

ExprItemWithUnary  = UnaryOperation ExprItem                                   {exprItemWithUnary} ;

SimpleExprItem     = ( IntegerConstant
                     / StringLiteral
                     / CharLiteral
                     / FuncCall
                     / LambdaDef
                     / Identifier ![(]
                     / ListComprehensions
                     / LBRK ExprList? !FOR RBRK
                     / LPAR Expr RPAR
                     )                                                         {simpleExprItem} ;

ExprList           = Expr ( COMMA Expr )* COMMA?                               {exprList} ;

ArgList            = Arg ( COMMA Arg )* COMMA?                                 {argList} ;

Arg                = ( !Keyword Identifier EQU Expr / Expr )                   {arg} ;

ArgDefList         = ArgDef ( COMMA ArgDef )* COMMA?                           {argDefList} ;

ArgDef             = !Keyword Identifier ( EQU Expr )?                         {argDef};

SelectorSuffix     = DOT ( Identifier ![(] / FuncCall )                        {selectorSuffix} ;

FuncDef            = DEF !Keyword Identifier LPAR ArgDefList? RPAR LWING
                     FuncStatement* ReturnStatement? RWING                     {funcDef} ;

LambdaDef          = LAMBDA LPAR ArgDefList? RPAR LWING
                     FuncStatement* ReturnStatement RWING                      {lambdaDef} ;

FuncStatement      = ( FuncCall / Assginment / IfStatement )                   {funcStatement} ;

ReturnStatement    = RETURN Expr                                               {returnStatement} ;

IfStatement        = IF LPAR Expr RPAR LWING FuncStatement* RWING
                     ( ELSE LWING FuncStatement* RWING )?                      {ifStatement} ;


//-----------------------------------------------------------------------//
//  Lexical elements                                                     //
//-----------------------------------------------------------------------//

//-------------------------------------------------------------------------
//  Keywords
//-------------------------------------------------------------------------

Keyword  = ( DEF / LAMBDA / RETURN / CONST / IF / ELSE / FOR / IN ) ;

DEF      = "def"      ! IdChar Spacing ;
LAMBDA   = "lambda"   ! IdChar Spacing ;
RETURN   = "return"   ! IdChar Spacing ;

IF       = "if"       ! IdChar Spacing ;
ELSE     = "else"     ! IdChar Spacing ;
FOR      = "for"      ! IdChar Spacing ;
IN       = "in"       ! IdChar Spacing ;

INCLUDE  = "include"  ! IdChar Spacing ;
SUBCLUDE = "subclude" ! IdChar Spacing ;
GLOB     = "glob"     ! IdChar Spacing ;
PATH     = "path"     ! IdChar Spacing ;
ECHO     = "echo"     ! IdChar Spacing ;
GENRULE  = "genrule"  ! IdChar Spacing ;

CONST    = ( TRUE / FALSE / NULL ) ;
TRUE     = "true"     ! IdChar Spacing ;
FALSE    = "false"    ! IdChar Spacing ;
NULL     = "null"     ! IdChar Spacing ;

//-------------------------------------------------------------------------
//  Operation
//-------------------------------------------------------------------------

UnaryOperation = ( BANG ) ;


Operation = ( PLUS
            / MINUS
            / INC
            / STAR
            / DIV
            / MOD

            / LT
            / GT
            / LE
            / GE
            / EQUEQU
            / BANGEQU
            );

//-------------------------------------------------------------------------
//  Constant
//-------------------------------------------------------------------------

IntegerConstant
    = ( DecimalConstant
      / HexConstant
      / OctalConstant
      )
    IntegerSuffix? Spacing {integerConstant}
    ;

DecimalConstant = [1-9][0-9]* {decimalConstant} ;

OctalConstant   = "0"[0-7]* {octalConstant} ;

HexConstant     = HexPrefix HexDigit+ {hexConstant} ;

HexPrefix       = "0x" / "0X" ;

HexDigit        = [a-f] / [A-F] / [0-9] ;

IntegerSuffix
    = [uU] Lsuffix?
    / Lsuffix [uU]?
    ;

Lsuffix
    = "ll"
    / "LL"
    / [lL]
    ;


//-------------------------------------------------------------------------
//  Identifier
//-------------------------------------------------------------------------

Identifier = IdNondigit IdChar* Spacing {identifier} ;
IdNondigit = [a-z] / [A-Z] ;
IdChar = [a-z] / [A-Z] / [0-9] / [_] ;


//-------------------------------------------------------------------------
//  Spacing
//-------------------------------------------------------------------------

Spacing = ( WhiteSpace / LineComment )* ;

WhiteSpace  = [ \n\r\t\u000B\u000C] ;

LineComment = "#" (!"\n" _)* EOL ;


//-------------------------------------------------------------------------
//  String Literals
//-------------------------------------------------------------------------

StringLiteral = ["] StringChar* ["] Spacing {stringLiteral} ;
CharLiteral   = ['] StringChar ['] Spacing  {charLiteral}   ;
StringChar = ( Escape / ![\"\n\\] _ )       {stringChar}    ;

Escape = SimpleEscape                       {escape}        ;
SimpleEscape = "\\" ['\"\\bfnrt]            {simpleEscape}  ;


//-------------------------------------------------------------------------
//  Punctuators
//-------------------------------------------------------------------------
LBRK       =  "["         Spacing ;
RBRK       =  "]"         Spacing ;
LPAR       =  "("         Spacing ;
RPAR       =  ")"         Spacing ;
LWING      =  "{"         Spacing ;
RWING      =  "}"         Spacing ;

BANG       =  "!"  ![=]   Spacing ;

PLUS       =  "+"  ![+=]  Spacing ;
MINUS      =  "-"  ![\-=>]Spacing ;
INC        =  "++"        Spacing ;
STAR       =  "*"         Spacing ;
DIV        =  "/"  ![=]   Spacing ;
MOD        =  "%"  ![=>]  Spacing ;


DOT        =  "."         Spacing ;
EQU        =  "="  !"="   Spacing ;
COMMA      =  ","         Spacing ;

LT         =  "<"  ![=]   Spacing ;
GT         =  ">"  ![=]   Spacing ;
LE         =  "<="        Spacing ;
GE         =  ">="        Spacing ;
EQUEQU     =  "=="        Spacing ;
BANGEQU    =  "!="        Spacing ;

EOL        =  [\r\n] / !_ ;
EOT        =  !_    ;
